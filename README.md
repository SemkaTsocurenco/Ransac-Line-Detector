# Ransac-Line-Detector
Метод распознования дорожной разметки методом Ransac


#
# Содержание

**1. Обзор метода RANSAC**

     1.1 Информация о методе

     1.2 Другие методы

**2. Разработка алгоритма распознавания разметки**

     2.1 Bird view преобразование

     2.2 HSV преобразование

**3. Применение алгоритма RANSAC**

**4. Результат**

**5. В разработке**
#

#


# Обзор метода RANSAC

Отклонения появляются в наборах данных по различным причинам, включая ошибки измерения и неправильный ввод данных. Они также могут быть присущи имеющимся данным.

В показанных данных мы видим типичный набор данных, встречающийся, например, при обработке сигналов:
![image](https://github.com/SemkaTsocurenco/Ransac-Line-Detector/assets/45175139/c3ec34ed-37ca-46d6-b37f-5b5672d75b12)


Отклонения легко заметить визуально, мы отмечаем их фиолетовым цветом:

![image](https://github.com/SemkaTsocurenco/Ransac-Line-Detector/assets/45175139/8b8540a6-2637-479c-bd32-4286380eed49)


Мы также можем видеть, что выбросы препятствуют дальнейшей обработке данных. В качестве примера мы рассмотрим линейную регрессию:

![image](https://github.com/SemkaTsocurenco/Ransac-Line-Detector/assets/45175139/776c90f9-c94e-4e15-9471-2baac89e7e5a)


Как мы можем видеть, линейная регрессия не описывает наши данные правильно.


### Устранение выбросов с помощью алгоритма RANSAC

Чтобы правильно обнаружить наши выбросы и построить модель, которая игнорирует их при вычислениях, мы используем алгоритм RANSAC. Это работает путем взятия случайного подмножества наших заданных данных и создания из него модели. Затем мы проверяем, насколько хорошо весь набор данных соответствует модели. Мы повторяем эти шаги до тех пор, пока не найдем модель, которая хорошо соответствует нашим данным. В этом процессе мы отмечаем все точки, которые не близки к ней, как отклонения.

![image](https://github.com/SemkaTsocurenco/Ransac-Line-Detector/assets/45175139/fb24ea3f-93ad-4cc3-87f7-8cbfe98e2a1a)


В центре алгоритма находится наш цикл "for". В этом цикле мы выбираем случайное подмножество наших данных, имеющее ранее выбранный размер. Для этих данных мы подгоняем нашу модель. Это может быть моделью любого типа, например, простая линейная регрессия. После подгонки модели мы проверяем, насколько далеко находятся все остальные точки из нашего исходного набора данных относительно модели во втором цикле for. Для этого расстояния мы используем параметр в качестве порогового значения. Исходя из этих пунктов, мы создаем новый список, называемый tempInlierAdd. Если размер этого списка больше нашего параметра, мы можем рассматривать его как кандидата на подходящую модель. Затем мы создаем модель на основе tempInlier и tempInlierAdd и сравниваем ее с лучшей моделью из наших предыдущих итераций.


Чтобы определить, на каком расстоянии от нашей подобранной линии могут находиться наши точки, чтобы по-прежнему рассматривать их как вкладные, мы используем параметр в качестве порога:

![image](https://github.com/SemkaTsocurenco/Ransac-Line-Detector/assets/45175139/3e86475e-a967-4411-b9d7-57d345b9e1c0)

Если наш порог выбран слишком маленьким, как на нашем рисунке, мы можем обнаружить слишком много точек в качестве выбросов. В большинстве реализаций RANSAC порог вычисляется как медиана значений y из нашего набора данных. Если пользователь не задал пороговое значение. Изменение порогового значения вручную в нашем примере дает гораздо более разумную классификацию выбросов:

![image](https://github.com/SemkaTsocurenco/Ransac-Line-Detector/assets/45175139/fa49fc03-e6d5-40bd-9bbc-4e71b8dcae5b)

Неправильный порог может не только выявить неправильные выбросы, но и привести к неправильной модели данных. Таким образом, важно выбрать его правильно.

### Другие методы
К сожалению, данные алгоритмы не подходят для детектирования дорожной разметки. Метод k-nn имеет слишком много минусов, таких как скорость выполнения. Поэтому её нельзя использовать в нашей системе, ведь данная система будет использоваться в live режиме. А метод SVM не подходит из-за того, что набор данных должен быть многоклассовым. В нашей задаче это не так

# Разработка алгоритма распознавания разметки

Для правильной работы алгоритма, нам потребуется реализовать ещё несколько алгоритмов, помимо самого RANSAC

    • Преобразование видео в bird view перспективу

    • Преобразование кадра в полутоновый формат 

## Bird view

- **Загрузка изображения:** Сначала нужно загрузить исходное изображение в формате OpenCV. Для этого можно использовать функцию _cv::imread_.
- **Определение точек перспективы:** Выбераем четыре точки, которые задают прямоугольник в исходном изображении. Этот прямоугольник будет областью интереса (Region of Interest, ROI), которую мы хотим преобразовать в "птичий вид". Эти точки должны быть выбраны так, чтобы они соответствовали углам объекта на исходном изображении.
- **Вычисление матрицы преобразования:** Для выполнения преобразования перспективы необходимо вычислить матрицу преобразования. Это можно сделать с помощью функции _cv::getPerspectiveTransform_, которая принимает координаты четырех точек на исходном изображении и соответствующие координаты на выходном изображении (ROI в "птичьем виде").
- **Применение преобразования:** Применяем матрицу преобразования к исходному изображению с помощью функции _cv::warpPerspective_.

Данный способ преобразования был реализован в классе. Клас позволяет так же выбрать точки ROI, благодаря чему настройка преобразования становится намного удобнее 

**Результат:**

![image](https://github.com/SemkaTsocurenco/Ransac-Line-Detector/assets/45175139/8e1716b3-0969-4c00-b8c6-7ad4182571e2)

**Окно настройки:**

![image](https://github.com/SemkaTsocurenco/Ransac-Line-Detector/assets/45175139/6cebeb80-236d-4453-b4e3-7d9b81c51076)

Параетры полученные после выполнения функции записываются в файл _data/bird_params.txt_

## HSV


- **Загрузка изображения:** Сначала нужно загрузить исходное изображение в формате OpenCV. Для этого можно использовать функцию _cv::imread_.
- **Преобразование в HSV:** Преобразуем исходное изображение в цветовое пространство HSV с помощью функции _cv::cvtColor_.
- **Извлечение каналов цвета:*** После преобразования в цветовое пространство HSV, можем получить отдельные каналы цвета (H, S и V) с помощью метода _cv::split_.
- **Использование каналов:** Теперь мы можем работать с отдельными каналами цвета по потребностямю


Данный способ преобразования был реализован в классе. Клас позволяет так же выбрать параметры преобразования, благодаря чему настройка преобразования становится намного удобнее 


**Результат:**

![image](https://github.com/SemkaTsocurenco/Ransac-Line-Detector/assets/45175139/55ed80f4-1903-4e8c-b8b2-113563ba838a)

**Окно настройки:**

![image](https://github.com/SemkaTsocurenco/Ransac-Line-Detector/assets/45175139/eed9fb01-1c43-46ea-bc3f-d0754eb4f5de)

Параетры полученные после выполнения функции записываются в файл _data/HSV_params.txt_

### Фильтрация изображения в HSV формате

Данный класс имеет ещё один метод, который позволяет отфильтровать изображение таким образом, чтобы на нём осталась только дорожная разметка. Фильтрация происходит при помощи методов:

- Применение морфологической операции закрытия к изображению
- Поиск контуров _cv::findContours_
- Фильтрация контуров на основе их размеров и формы
- Создание ядра для вертикального фильтра. Применение вертикального фильтра к изображению. 
- Создание ядра для морфологической операции открытия (удаление шумовых объектов)

**Результат фильтрации**

![image](https://github.com/SemkaTsocurenco/Ransac-Line-Detector/assets/45175139/e46d28a9-4dd7-4f03-8f91-00ce9e57fb6c)


# Применение алгоритма RANSAC

Для реализации алгоритма была использована библиотека mrpt. Функция _ransac_detect_2D_lines_ позволяет получить вертикальные линии в формате A*x + B*y + C = 0. Функция принимает параметры _min_inliers_       Минимальное количество точек, необходимое для определения линии. _DIST_THRESHOLD_  Пороговое значение для определения, является ли точка внутри линии.


**Отображение результатов функции**

![image](https://github.com/SemkaTsocurenco/Ransac-Line-Detector/assets/45175139/1e7ffecb-4e10-45f1-86f7-928fc8aacf83)

# Работа с полученными данными 

Данные полученные из функции RANSAC преобразуем таким образом, чтобы линия была полиномом, это делается при помощи таких действий :
- Инициализируем матрицу A и вектор B для системы уравнений.
- Заполняем матрицу A и вектор B на основе координат x и y точек.
- Решаем систему линейных уравнений методом Гаусса.
- Вычисляем коэффициенты полинома и формируем уравнение линии.
- Создаем _TLine2D_ с полученными коэффициентами полинома.

Далее полученные линии заносим в контейнер для линий, он реализован с момощью класса container. Делается это для того, чтобы мы могли учитывать предыдущие результаты работы функции. Метод _normolize_data_ позволяет оценивать верность определения линии на основе результатов с предыдущих фреймов. Таким образом мы нормализируем данные, получая выборку которая лучше всего подходит под реальность.

**Результат нормализации данных**

![image](https://github.com/SemkaTsocurenco/Ransac-Line-Detector/assets/45175139/723ae7c9-e4ba-470a-92fe-ef0d706f32ce)

# Результат

После всех преобразоаний мы возвращаем изображение в исходную перспективу при помощи метода _return_bird_ класса _Bird_view_.
из отфильтрованных данных находим расстояние от камеры, которая снимает видео до ближайшей дорожной разметки, а так же отмечаем полосу, в которой движется автомобиль. Расстояние высчитывается из знаний о том, что стандартная ширина дороги равна 3.75 метра
Значения выводим на изображение и в командную строку

**Финальный результат работы кода**

![image](https://github.com/SemkaTsocurenco/Ransac-Line-Detector/assets/45175139/034bd4bc-6059-4a2b-bdf0-245cf85d9786)


# В разработке:

- Добавить в код _CameraDetector_ который позволит принимать виде прямиком с камеры, подключенной к БУБА. 
- Доделать распознование типа разметки (сплошная, прерывистая)
- Добавить вычисление метрик, это позволит оценить данный алгоритм качественно



#
